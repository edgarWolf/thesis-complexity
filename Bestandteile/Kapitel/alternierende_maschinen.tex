\chapter{Alternierung} \label{chapter: Alternierung}

\section{Begriffsklärung} \label{section: Begriffsklärung}
Die Alternierung in der Komplexitätstheorie meint eine Verallgemeinerung des Nichtdeterminusmus. Mittels dieser Verallgemeinerung 
können diverse Beweise simplifiziert werden, und Verbindungen zu anderen Komplexitätsklassen gezogen werden \cite{sipser_introduction_2012} \cite{chandra_alternation_1976}. Ein Algorithmus, der auf Alternierung basiert,
kann wie ein gewöhnlicher nichtdeterministischer Algorithmus bei jedem Berechnungsschritt in mehrere Zustände überführt werden. Der Unterschied liegt hier bei dem Modus der Akzeptanz:
Während ein nichtdeterministischer Algorithmus akzeptiert, wenn mindestens ein Berechnugspfad akzeptiert, so tritt bei einem alternierenden Algorithmus eine Fallunterscheidung ein.
Die aktuelle Berechnug innerhalb des Algorithmus akzeptiert dann entweder, wenn wie beim Nichtdeterminusmus, mindestens ein Berechnugspfad akzeptiert, oder wenn alle Berechnugspfade akzeptieren.
Entscheidend für den Modus der Akzeptanz der Berechnung ist die Kennzeichnung des Berechnungsschrittes, der die Information enthält, unter welchem Modus dieser akzeptiert \cite{sipser_introduction_2012}.
Diese Kennzeichnung wird in der Literatur meist über die logischen Quantoren $\exists$ und $\forall$ vorgenommen, manche Autoren wie Sipser verwenden die Symbole $\land$ und $\lor$, für die Darstellung als logisches Und bzw. als logisches Oder.
Im ersten Fall akzeptiert die Berechnung, wenn mindestens ein Kind-Berechnugspfad akzeptiert, analog akzeptiert ein universeller Zustand genau dannn, wenn alle Kind-Berechnugspfade akzeptieren.
Eine Analogie hierfür könnte ein Prozess in einem Computer sein, der bei jedem Berechnungsschritt mehrere neue Prozesse erzeugt.
Jeder dieser Prozesse enthält eine Information darüber, ob er eine existenzielle oder universelle Berechnug durchführt. Der erzeugende Prozess gibt nun selber $1$ zurück, wenn er sich in einem existenziellen Zustand befindet
und mindestens ein Kind-Prozess mit $1$ antwortet, oder er sich in einem universellen Prozess befindet und alle Prozesse mit $1$ antworten \cite{sipser_introduction_2012}.
Der Nichtdeterminismus kann als Spezialfall der Alternierung betrachtet werden, bei dem Berechungen ausschließlich existenziell durchgeführt werden \cite{chandra_alternation_1976}.

\section{Alternierende Turingmaschinen} \label{section: alternierende Turingmaschine}
Das Konzept der Alternierung lässt sich auf Turingmaschinen übetragen, wodurch sich folgende Definition ergibt:
\begin{definition}[Alternierende Turingmaschine (ATM)]\cite{pass_lecture_nodate}
    Eine alternierende Turingmaschine ATM ist eine nichtdeterministische Turingmaschine NDTM $M$, bei der jeder Zustand mit einem 
    Element aus der Menge \{$\forall$, $\exists$, \texttt{accept}, \texttt{halt}\} gekennzeichnet ist.
\end{definition}

Eine ATM kann dabei genau wie eine NDTM bei jedem Berechnungsschritt in mehrere Zustände übergehen, jedoch operiert diese nicht
wie die NDTM zwangsläufig in einem existenziellen Modus, sodass sie akzeptiert, wenn es einen akzeptierenden Berechungspfad gibt, sondern entsprechend der Markierung des Zustandes.
Der Name \enquote{alternierende Turingmaschine} kommt daher, dass die Turingmaschine zwischen dem Existenz- und Universalqunator alternieren kann.
Die Akzeptanz einer Eingabe bei einer ATM kann formal wie folgt definiert werden:
\begin{definition}[Akzeptanz einer alternierenden Turingmaschine]\cite{arora_computational_2009}
    Sei $G_{M, x}$ der Konfigurationsgraph der ATM $M$ auf die Eingabe $x \in \{0,1\}*$, sodass eine Kante von einer Konfiguration $C$ zu 
    einer Konfiguration $C'$ einen Übergang von $C$ zu $C'$ über die Transitionsfunktion von $M$ darstellt. Dann ist die Akzeptanz über folgenden
    Markierungsalgorithmus definiert:

    \begin{itemize}
        \item Markiere die Konfigurationen terminierend in einem akzeptierenden Zustand $C_{accept}$ mit \texttt{ACCEPT}.
    \end{itemize}
    \begin{itemize}        
        \item Wenn eine Konfiguration $C$ mit $\exists$ markiert ist, und es eine Kante von $C$ zu $C'$ mit Markierung \texttt{ACCEPT} gibt, markiere $C$ mit \texttt{ACCEPT}.
        \item Wenn eine Konfiguration $C$ mit $\forall$ markiert ist, und alle Kanten von $C$ zu Konfigurationen $C'$ mit Markierung \texttt{ACCEPT} führen, markiere $C$ mit \texttt{ACCEPT}.
        \item Wiederhole die obigen Schritte, bis keine weitere Markierung mehr möglich ist.
    \end{itemize}

    Die ATM M akzeptiert genau dann, wenn am Ende dieses Algorithmus die Startkonfiguration $C_{start}$ mit \texttt{ACCEPT} markiert ist.
\end{definition}
\section{Alternierende Komplexitätsklassen} \label{section: Komplexitätsklassen bei alternierenden TMs}
Aus dieser hinzugekommenen Art der Turingmaschinenen ergeben sich entsprechende Komplexitätsklassen,
um die Komplexität dieser Turingmaschinen formal beschreiben zu können:
\begin{definition}[Alternierende Komplexitätsklassen] \cite{sipser_introduction_2012}
    % Check: Muss hier nicht O Notation?
    \\ATIME($f(n)$) ist die Menge Menge aller Sprachen, die von einer $f(n)$-zeitbeschränkten alternierenden Turingmaschine entschieden werden können. \\
    ASPACE($f(n)$) ist die Menge aller Sprachen, die von einer $f(n)$-platzbeschränkten alternierenden Turingmaschine entschieden werden können.
\end{definition}
Anhand dieser allgemeinenen Definition der Komplexitätsklassen ergeben sich die konkreten Pendants zu den bisher bekannten Klassen:

\begin{definition}[Die Klasse AL]\cite{sipser_introduction_2012}
    $$\text{AL} = \bigcup_{c \in \mathbb{N}} \text{ASPACE}(c \cdot log(n))$$
    AL ist die Menge aller Sprachen, die von einer logarithmisch-platzbeschränkten alternierenden Turingmaschine entschieden werden können.
\end{definition}

\begin{definition}[Die Klasse AP]\cite{arora_computational_2009}
    $$\text{AP} = \bigcup_{c \in \mathbb{N}} \text{ATIME}(n^c)$$
    AP ist die Menge aller Sprachen, die von einer polynomiell-zeitbeschränkten alternierenden Turingmaschine entschieden werden können.
\end{definition}

\begin{definition}[Die Klasse APSPACE]\cite{sipser_introduction_2012}
    $$\text{APSPACE} = \bigcup_{c \in \mathbb{N}} \text{ASPACE}(n^c)$$
    APSPACE ist die Menge aller Sprachen, die von einer polynomiell-platzbeschränkten alternierenden Turingmaschine entschieden werden können. 
\end{definition}

Besonders für die Klasse AP ergibt sich ein interessanter Zusammenhang zur platzbasierten Komplexitätsklasse PSPACE:


\begin{theorem}
    AP = PSPACE
\end{theorem}

\begin{proof}[Beweisskizze] \cite{arora_computational_2009} \cite{sipser_introduction_2006}
    Für die Beweisskizze muss die Inklusion in beide Richtungen gezeigt werden, also AP $\subseteq$ PSPACE und PSPACE $\subseteq$ AP. \\
    Die erste Inklusion folgt aus dem PSPACE-vollständigen Problem \texttt{TQBF}, bei dem eine mit Quantoren versehene logische Formel auf Erfüllbarkeit geprüft wird.
    Eine alternierende Turingmaschine $M$ kann einfach jede Belegung einer mit $\exists$ versehenen Variable existenziell raten, analog jede Belegung einer mit $\forall$ 
    versehenen Variable universell.\\
    Das Argument dafür, dass AP $\subseteq$ PSPACE ist, kann auf ein Erreichbarkeitsproblem, ähnlich wie bei dem Satz von Savitch zurückgeführt werden:
    Die Tiefe der Berechungspfade einer ATM sind polynomiell beschränkt, sodass die Erreichbarkeit von einer Konfiguration $c_1$ zu $c_2$ geprüft werden kann, indem eine Konfiguration existenziell $c_m$
    zwischen $c_1$ und $c_2$ geraten wird. Dann wird universell geprüft, ob $c_1$ $c_m$ erreichen kann, sowie ob $c_m$ $c_2$ erreichen kann.
    Durch diese rekursive Prüfung wird nur polynomiell viel Platz benötigt, um die Berechnung einer ATM zu simulieren. 
\end{proof}