\chapter{Alternierung} \label{chapter: Alternierung}

\section{Begriffsklärung} \label{section: Begriffsklärung}
Die Alternierung in der Komplexitätstheorie meint eine Verallgemeinerung des Nichtdeterminusmus. Mittels dieser Verallgemeinerung 
können diverse Beweise simplifiziert werden, und Verbindungen zu anderen Komplexitätsklassen gezogen werden \cite{sipser_introduction_2012} \cite{chandra_alternation_1976}. Ein Algorithmus, der auf Alternierung basiert,
kann wie ein gewöhnlicher nichtdeterministischer Algorithmus bei jedem Berechnungsschritt in mehrere Zustände überführt werden. Der Unterschied liegt hier bei dem Modus der Akzeptanz:
Während ein nichtdeterministischer Algorithmus akzeptiert, wenn mindestens ein Berechnugspfad akzeptiert, so tritt bei einem alternierenden Algorithmus eine Fallunterscheidung ein.
Die aktuelle Berechnug innerhalb des Algorithmus akzeptiert dann entweder, wenn wie beim Nichtdeterminusmus, mindestens ein Berechnugspfad akzeptiert, oder wenn alle Berechnugspfade akzeptieren.
Entscheidend für den Modus der Akzeptanz der Berechnung ist die Kennzeichnung des Berechnungsschrittes, der die Information enthält, unter welchem Modus dieser akzeptiert \cite{sipser_introduction_2012}.
Diese Kennzeichnung wir in der Literatur meist über die logischen Quantoren $\exists$ und $\forall$ vorgenommen, manche Autoren wie Sipser verwenden die Symbole $\land$ und $\lor$, für die Darstellung als logisches Und bzw. als logisches Oder.
Im ersten Fall akzeptiert die Berechnung, wenn mindestens ein Kind-Berechnugspfad akzeptiert, analog akzeptiert ein universeller Zustand genau dannn, wenn alle Kind-Berechnugspfade akzeptieren.
Eine Analogie hierfür könnte ein Prozess in einem Computer sein, der bei jedem Berechnungsschritt mehrere neue Prozesse erzeugt.
Jeder dieser Prozesse enthält eine Information darüber, ob er eine existenzielle oder universelle Berechnug durchführt. Der erzeugende Prozess gibt nun selber $1$ zurück, wenn er sich in einem existenziellen Zustand befindet
und mindestens ein Kind-Prozess mit $1$ antwortet, oder er sich in einem universellen Prozess befindet und alle Prozesse mit $1$ antworten \cite{sipser_introduction_2012}.
Wir können daher den Nichtdeterminusmus als einen Spezalfall der Alternierung auffassen, bei dem Berechungen ausschließlich existenziell durchgeführt werden \cite{chandra_alternation_1976}.

\section{Alternierende Turingmaschinen} \label{section: alternierende Turingmaschine}
Das Konzept der Alternierung lässt sich auf Turingmaschinen übetragen, wodurch sich folgende Definition ergibt:
\begin{definition}[Alternierende Turingmaschine (ATM)]\cite{pass_lecture_nodate}
    Eine alternierende Turingmaschine ATM ist eine nichtdeterministische Turingmaschine NDTM $M$, bei der jeder Zustand mit einem 
    Element aus der Menge \{$\forall$, $\exists$, \texttt{accept}, \texttt{halt}\} gekennzeichnet ist.
\end{definition}

Eine ATM kann dabei genau wie eine NDTM bei jedem Berechnungsschritt in mehrere Zustände übergehen, jedoch operiert diese nicht
wie die NDTM zwangsläufig in einem existenziellen Modus, sodass sie akzeptiert, wenn es einen akzeptierenden Berechungspfad gibt, sondern entsprechend der Markierung des Zustandes.
Der Name \enquote{alternierende Turingmaschine} kommt daher, dass die Turingmaschine zwischen dem Existenz- und Universalqunator alternieren kann.
Die Akzeptanz einer Eingabe bei einer ATM kann formal wie folgt definiert werden:
\begin{definition}[Akzeptanz einer alternierenden Turingmaschine]\cite{arora_computational_2009}
    Sei $G_{M, x}$ der Konfigurationsgraph der ATM $M$ auf die Eingabe $x \in \{0,1\}*$, sodass eine Kante von einer Konfiguration $C$ zu 
    einer Konfiguration $C$ einen Übergang von $C$ zu $C'$ über die Transitionsfunktion von $M$ darstellt. Dann ist die Akzeptanz über folgenden
    Markierungsalgorithmus definiert:

    \begin{itemize}
        \item Markiere die Konfigurationen terminierend in einem akzeptierenden Zustand $C_{accept}$ mit \texttt{ACCEPT}.
    \end{itemize}
    Wiederhole
    \begin{itemize}        
        \item Wenn eine Konfiguration $C$ mit $\exists$ markiert ist, und es eine Kante von $C$ zu $C'$ mit Markierung \texttt{ACCEPT} gibt, markiere $C$ mit \texttt{ACCEPT}.
        \item Wenn eine Konfiguration $C$ mit $\forall$ markiert ist, und alle Kanten von $C$ zu Konfigurationen $C'$ mit Markierung \texttt{ACCEPT} führen, markiere $C$ mit \texttt{ACCEPT}.
    \end{itemize}
    bis keine Markierung mehr möglich ist.

    Die ATM M akzeptiert genau dann, wenn am Ende dieses Algorithmus die Startkonfiguration $C_{start}$ mit \texttt{ACCEPT} markiert ist.
\end{definition}
\section{Alternierende Komplexitätsklassen} \label{section: Komplexitätsklassen bei alternierenden TMs}
Aus dieser hinzugekommenen Art der Turingmaschinenen ergeben sich entsprechende Komplexitätsklassen,
um die Komplexität dieser Turingmaschinen formal beschreiben zu können:
\begin{definition}[Alternierende Komplexitätsklassen]
    $ATIME(f(n))$ ist die Menge Menge aller Sprachen, die von einer $f(n)$-zeitbeschränkten alternierenden Turingmaschine M entschieden werden können. \\
    $ASPACE(f(n))$ ist die Menge aller Sprachen, die von einer $f(n)$-platzbeschränkten alternierenden Turingmaschine M entschieden werden können.
\end{definition}
Anhand dieser allgemeinenen Definition der Komplexitätsklassen ergeben sich die konkreten Pendants zu den bisher bekannten Klassen:
\begin{definition}[Die Klasse $AP$]
    $AP$ ist die Menge aller Sprachen, die von einer polynomiell-zeitbeschränkten Turingmaschine entschieden werden können.
\end{definition}
Besonders für diese Klasse ergibt sich ein interessanter Zusammenhang zur platzbasierten Komplexitätsklasse $PSPACE$:

\begin{theorem}
    $AP = PSPACE$
\end{theorem}

\begin{proof}[Beweis]
    Das ist ein Beweis.
\end{proof}