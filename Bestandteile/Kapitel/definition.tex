\chapter{Polynomialzeithierarchie (PH)} \label{chapter: Polynomialzeithierarchie (PH)}
Die Polynomialzeithierarchie (kurz PH) bildet als Komplexitätsklasse Probleme ab, die sich nicht effizient mittels Nichtdeterminusmus lösen lassen, aber gleichzeitig 
nicht $EXPTIME$ zuzuordnen sind. Die PH bietet einen Formalismus, um auch diese Probleme adäquat zu untersuchen und sie auf ihre Komplexität hin bewerten zu können.
Die PH verfügt dabei über verschiedene Definitionen, die aber allesamt äquivalent sind.
% TODO: Hier wenn Zeit und Platz das mit EXACT-INDSET oder so einfügen


\section{Definition mit alternierenden Quantoren} \label{section: Definition PH mit alternierenden Quantoren}
Eine Möglichkeit der Definition besteht übr die der alternierenden Quantoren. Es wird dabei zwischen zwei Sprachdefinitionen unterschieden.
Sei dafür $p$ ein Polynom und $i \geq 1$. Dann ist eine Sprache $L$ in $\Sigma^p_i$, wenn es polynomiell zeitbeschränkte Turingmaschine $M$ gibt, 
sodass für jede Eingabe $x \in \{0,1\}^*$ gilt \cite{rossman_complexity_2015}:
%todo: Die Erklärung der Quantifizierer und wann welcher Qunator hergenommen wir hinzufügen.%
\begin{align*}
    x \in L \Leftrightarrow \exists u_1 \in \{0,1\}^{p(|x|)} \forall u_2 \in \{0,1\}^{p(|x|)} ... Q_i u_i \in \{0,1\}^{p(|x|)} : M(x, u_1, ..., u_i) = 1
\end{align*}
wobei $Q_i = \exists$, wenn $i$ gerade ist, sonst $Q_i = \forall$. \\
Analog ist eine Sprache $L$ in $\Pi^p_i$, wenn es eine polynomiell zeitbeschränkte Turingmaschine $M$ gibt, sodass für jede Eingabe $x \in \{0,1\}^*$ gilt \cite{arora_computational_2009}:
\begin{align*}
    x \in L \Leftrightarrow \forall u_1 \in \{0,1\}^{p(|x|)} \exists u_2 \in \{0,1\}^{p(|x|)} ... Q_i u_i \in \{0,1\}^{p(|x|)} : M(x, u_1, ..., u_i) = 1
\end{align*}
wobei $Q_i = \forall$, wenn $i$ gerade ist, sonst $Q_i = \exists$.
Aus diesen Definitionen kann sofort gefolgert werden dass $\Sigma^p_1 = NP$ und $\Sigma^p_1 = coNP$, denn die boolsche Formel reduziert auf 
den ersten Quanotren entspricht genau der Definition der entsprechenden Komplexitätsklassen $NP$ bzw. $coNP$.
Die Polynomialzeithierarchie entspricht dann der Vereinigung über alle $\Sigma^p_i$, sowie der Vereinigung aller $\Pi^p_i$ \cite{sipser_introduction_2012}:
\begin{align*}
    PH = \bigcup_{i \geq 1} \Sigma^p_i = \bigcup_{i \geq 1} \Pi^p_i 
\end{align*}
\section{Definition mit alternierenden Turingmaschinen} \label{section: Definition PH mit ATM}
Eine äquivalente und mit der Definition über die alternierenden Quantoren verwandte Definition ist über alternierende Turingmaschinen möglich.
Das Konzept wurde bereits in \ref{section: alternierende Turingmaschine} erläutert und dient nun als Basis für die Definition der Polynomialzeithierarchie.
Sei dafür $M$ eine $f(n)$ zeitbeschränkte ATM und $i \geq 1$  mit $i - 1$ mit  Alternierungen. Dann entscheidet M die Sprache $\Sigma_i TIME(f(n))$, wenn der iniitiale Zustand ein existenzieller ist,
oder die Sprache $\Pi_i TIME(f(n))$, falls der erste Zustand ein universeller ist \cite{arora_computational_2009}.
Die Sprachen $\Sigma^p_i$ und $\Pi^p_i$ sind dann definiert als \cite{arora_computational_2009}:
\begin{align*}
    \Sigma^p_i = \bigcup_{c \in \mathbb{N}} \Sigma_i TIME(f(n)) \\
    \Pi^p_i = \bigcup_{c \in \mathbb{N}} \Pi_i TIME(f(n))
\end{align*}
$\Sigma^p_i$ beschreibt also die Menge der Sprachen, die von einer polynomiell zeitbeschränkten ATM $M$ mit existenziellem Startzustand und höchstens $i-1$ Alternierungen entschieden werden.
$\Pi^p_i$ beschreibt analog die Menge der Sprachen, die von einer polynomiell zeitbeschränkten ATM $M$ mit universellem Startzustand und höchstens $i-1$ Alternierungen entschieden werden.
\section{Definition mit Orakel-Turingmaschinen} \label{section: Definition PH mit Orakel-Turingmaschinen}
Eine weitere Definition erfolgt über Turingmaschinen mit Zugriff auf ein Orakel. Dabei wird auf ein Orakel zugegriffen,
das ein vollständiges Problem einer Komplexitätsklasse entscheiden kann. Sei für die folgenden Ausführungen $A^B$, sodass eine $A$ eine Turingmaschine, die die Sprache $A$ entscheidet mit Zugriff auf ein Orakel ist, welches $B$ entscheiden kann.
Dann ist die Polynomialzeithierarchie induktiv, für $i \geq 0$ definiert als \cite{rothe_komplexitatstheorie_2008}:
\begin{align*}
    & \Delta^p_0 = \Sigma^p_0 = \Pi^p_0 = P; \\
    & \Delta^p_{i+1} = P^{\Sigma^p_i}, \Sigma^p_{i+1} = NP^{\Sigma^p_i}, \Pi^p_{i+1} = coNP^{\Sigma^p_i}, \\
    & PH = \bigcup_{k \geq 0} \Sigma^p_k
\end{align*}
% TODO:  Hier nochmal drauf eingehen, dass die Deltas hier neu sind, und das P nochmal explizit einbezogen wird.